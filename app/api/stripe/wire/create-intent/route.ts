/**
 * POST /api/stripe/wire/create-intent
 *
 * Creates a Stripe PaymentIntent configured for bank transfer instructions (wire/bank transfer),
 * creates an Order in Firestore with status awaiting_wire, and reserves the listing.
 *
 * IMPORTANT:
 * - This preserves escrow model: funds land in platform Stripe balance, order becomes paid_held only via Stripe webhook.
 * - No off-platform payments; wire details are generated by Stripe.
 */

import { Timestamp } from 'firebase-admin/firestore';
import Stripe from 'stripe';
import { stripe, calculatePlatformFee, isStripeConfigured } from '@/lib/stripe/config';
import { validateRequest, createWireIntentSchema } from '@/lib/validation/api-schemas';
import { rateLimitMiddleware, RATE_LIMITS } from '@/lib/rate-limit';
import { createAuditLog } from '@/lib/audit/logger';
import { logInfo, logWarn } from '@/lib/monitoring/logger';
import { getAdminAuth, getAdminDb } from '@/lib/firebase/admin';
import { containsProhibitedKeywords } from '@/lib/compliance/validation';
import { formatWireInstructionsFromPaymentIntent } from '@/lib/stripe/wire';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

function json(body: any, init?: { status?: number; headers?: Record<string, string> | Headers }) {
  const headers =
    init?.headers instanceof Headers
      ? Object.fromEntries(init.headers.entries())
      : (init?.headers as Record<string, string> | undefined);

  return new Response(JSON.stringify(body), {
    status: init?.status ?? 200,
    headers: {
      'content-type': 'application/json',
      ...(headers || {}),
    },
  });
}

// Small shim so we don't have to rewrite every `NextResponse.json(...)` call in this file.
const NextResponse = { json };

export async function POST(request: Request) {
  try {
    let auth: ReturnType<typeof getAdminAuth>;
    let db: ReturnType<typeof getAdminDb>;
    try {
      auth = getAdminAuth();
      db = getAdminDb();
    } catch (e: any) {
      logWarn('Firebase Admin init failed in /api/stripe/wire/create-intent', {
        code: e?.code,
        message: e?.message,
        missing: e?.missing,
      });
      return NextResponse.json(
        {
          error: 'Server is not configured for payments yet',
          code: e?.code || 'FIREBASE_ADMIN_INIT_FAILED',
          message: e?.message || 'Failed to initialize Firebase Admin SDK',
          missing: e?.missing || undefined,
        },
        { status: 503 }
      );
    }

    if (!isStripeConfigured() || !stripe) {
      return NextResponse.json(
        { error: 'Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.' },
        { status: 503 }
      );
    }

    // Rate limiting (before auth to prevent brute force)
    const rateLimitCheck = rateLimitMiddleware(RATE_LIMITS.checkout);
    const rateLimitResult = await rateLimitCheck(request as any);
    if (!rateLimitResult.allowed) {
      return NextResponse.json(rateLimitResult.body, {
        status: rateLimitResult.status,
        headers: {
          'Retry-After': rateLimitResult.body.retryAfter.toString(),
        },
      });
    }

    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized - Missing or invalid authorization header' }, { status: 401 });
    }

    const token = authHeader.split('Bearer ')[1];
    let decodedToken;
    try {
      decodedToken = await auth.verifyIdToken(token);
    } catch {
      return NextResponse.json({ error: 'Unauthorized - Invalid token' }, { status: 401 });
    }

    const buyerId = decodedToken.uid;

    // Wire requires verified email (and authentication).
    const buyerRecord = await auth.getUser(buyerId).catch(() => null as any);
    if (buyerRecord?.emailVerified !== true) {
      return NextResponse.json(
        {
          error: 'Email verification required',
          code: 'EMAIL_NOT_VERIFIED',
          message: 'Please verify your email address before using wire transfer.',
        },
        { status: 403 }
      );
    }

    let body: any;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: 'Invalid JSON in request body' }, { status: 400 });
    }

    const validation = validateRequest(createWireIntentSchema, body);
    if (!validation.success) {
      return NextResponse.json({ error: validation.error, details: validation.details?.errors }, { status: 400 });
    }

    const { listingId, offerId } = validation.data as any;

    // Get listing
    const listingRef = db.collection('listings').doc(listingId);
    const listingDoc = await listingRef.get();
    if (!listingDoc.exists) return NextResponse.json({ error: 'Listing not found' }, { status: 404 });
    const listingData = listingDoc.data()!;

    // If a high-ticket checkout is pending for this listing, block additional checkouts
    if (listingData.purchaseReservedByOrderId) {
      return NextResponse.json(
        { error: 'Listing is reserved pending payment confirmation. Please try again later.' },
        { status: 409 }
      );
    }

    // Best Offer checkout path (accepted offer -> pay at agreed price)
    let offerData: any = null;
    let offerRef: any = null;
    if (offerId) {
      offerRef = db.collection('offers').doc(String(offerId));
      const offerSnap = await offerRef.get();
      if (!offerSnap.exists) return NextResponse.json({ error: 'Offer not found' }, { status: 404 });
      offerData = offerSnap.data();

      if (offerData?.listingId !== listingId) return NextResponse.json({ error: 'Offer does not match listing' }, { status: 400 });
      if (offerData?.buyerId !== buyerId) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
      if (offerData?.status !== 'accepted') return NextResponse.json({ error: 'Offer is not accepted' }, { status: 400 });
      if (listingData?.offerReservedByOfferId && listingData.offerReservedByOfferId !== String(offerId)) {
        return NextResponse.json({ error: 'Listing is reserved by another offer' }, { status: 409 });
      }
      if (!listingData?.offerReservedByOfferId) {
        return NextResponse.json({ error: 'Listing is not reserved for this offer' }, { status: 409 });
      }
      if (listingData?.sellerId !== offerData?.sellerId) return NextResponse.json({ error: 'Offer seller mismatch' }, { status: 400 });
    }

    if (listingData.status !== 'active') {
      return NextResponse.json({ error: 'Listing is not available for purchase' }, { status: 400 });
    }

    // If listing is reserved by an accepted offer, block non-offer checkout
    if (!offerId && listingData.offerReservedByOfferId) {
      return NextResponse.json({ error: 'Listing is reserved by an accepted offer' }, { status: 409 });
    }

    // Determine purchase amount (server authoritative)
    let purchaseAmountUsd: number;
    if (offerId) {
      if (listingData.type !== 'fixed' && listingData.type !== 'classified') {
        return NextResponse.json({ error: 'Offer checkout is only supported for fixed/classified listings' }, { status: 400 });
      }
      const accepted = Number(offerData?.acceptedAmount ?? offerData?.currentAmount);
      if (!Number.isFinite(accepted) || accepted <= 0) {
        return NextResponse.json({ error: 'Offer has an invalid accepted amount' }, { status: 400 });
      }
      purchaseAmountUsd = accepted;
    } else if (listingData.type === 'fixed') {
      if (!listingData.price || listingData.price <= 0) return NextResponse.json({ error: 'Listing does not have a valid price' }, { status: 400 });
      purchaseAmountUsd = listingData.price;
    } else if (listingData.type === 'auction') {
      // Verify auction has ended
      if (listingData.endsAt) {
        const endsAt = listingData.endsAt.toDate();
        if (endsAt.getTime() > Date.now()) {
          return NextResponse.json({ error: 'Auction has not ended yet' }, { status: 400 });
        }
      }
      const bidsRef = db.collection('bids');
      const winningBidQuery = await bidsRef.where('listingId', '==', listingId).orderBy('amount', 'desc').limit(1).get();
      if (winningBidQuery.empty) return NextResponse.json({ error: 'No bids found for this auction' }, { status: 400 });
      const winningBidData = winningBidQuery.docs[0]!.data();
      if (winningBidData.bidderId !== buyerId) {
        return NextResponse.json({ error: 'You are not the winning bidder' }, { status: 403 });
      }
      purchaseAmountUsd = Number(winningBidData.amount);
    } else if (listingData.type === 'classified') {
      if (!listingData.price || listingData.price <= 0) return NextResponse.json({ error: 'Listing does not have a valid price' }, { status: 400 });
      purchaseAmountUsd = listingData.price;
    } else {
      return NextResponse.json({ error: 'This listing type does not support wire transfer' }, { status: 400 });
    }

    const amountCents = Math.round(purchaseAmountUsd * 100);

    // NOTE: We intentionally do NOT enforce a hard minimum for wire here.
    // If product policy changes later, gate it here server-side.

    // Prevent buying own listing
    if (listingData.sellerId === buyerId) {
      return NextResponse.json({ error: 'You cannot purchase your own listing' }, { status: 400 });
    }

    // TX-only enforcement for animal listings
    const animalCategories = ['whitetail_breeder', 'wildlife_exotics', 'cattle_livestock'];
    if (animalCategories.includes(listingData.category)) {
      if (listingData.location?.state !== 'TX') {
        return NextResponse.json({ error: 'Animal listings must be located in Texas.' }, { status: 400 });
      }
      const buyerRef = db.collection('users').doc(buyerId);
      const buyerDoc = await buyerRef.get();
      if (!buyerDoc.exists) return NextResponse.json({ error: 'Buyer profile not found. Please complete your profile.' }, { status: 400 });
      const buyerData = buyerDoc.data()!;
      const buyerState = buyerData.profile?.location?.state;
      if (!buyerState || buyerState !== 'TX') {
        return NextResponse.json(
          { error: 'Only Texas residents can purchase animal listings. Please update your profile location to Texas.', code: 'TEXAS_ONLY_REQUIRED' },
          { status: 400 }
        );
      }
      if (containsProhibitedKeywords(listingData.title) || containsProhibitedKeywords(listingData.description)) {
        return NextResponse.json({ error: 'Listing contains prohibited content and cannot be purchased.' }, { status: 400 });
      }
    }

    // Seller readiness checks (payout-ready)
    const sellerRef = db.collection('users').doc(listingData.sellerId);
    const sellerDoc = await sellerRef.get();
    if (!sellerDoc.exists) return NextResponse.json({ error: 'Seller not found' }, { status: 404 });
    const sellerData = sellerDoc.data()!;
    const sellerStripeAccountId = sellerData.stripeAccountId;
    const isPayoutReady =
      sellerStripeAccountId &&
      (sellerData.chargesEnabled ?? false) &&
      (sellerData.payoutsEnabled ?? false) &&
      (sellerData.stripeDetailsSubmitted ?? false) &&
      (sellerData.stripeOnboardingStatus || 'not_started') === 'complete';
    if (!isPayoutReady) {
      return NextResponse.json({ error: 'Seller is not ready to receive payouts yet. Please try later.', code: 'SELLER_NOT_PAYOUT_READY' }, { status: 400 });
    }

    // Fees (flat)
    const platformFeeCents = calculatePlatformFee(amountCents);
    const sellerAmountCents = amountCents - platformFeeCents;

    // Ensure Stripe Customer exists (required for customer_balance bank transfer instructions)
    const buyerUserRef = db.collection('users').doc(buyerId);
    const buyerUserDoc = await buyerUserRef.get();
    const buyerUserData = buyerUserDoc.exists ? (buyerUserDoc.data() as any) : {};
    let stripeCustomerId: string | undefined = buyerUserData?.stripeCustomerId;

    if (!stripeCustomerId) {
      const customer = await stripe.customers.create({
        email: decodedToken.email || buyerRecord?.email || undefined,
        metadata: { buyerId },
      });
      stripeCustomerId = customer.id;
      // Best-effort persist to user doc (no undefined writes)
      await buyerUserRef.set({ stripeCustomerId, updatedAt: Timestamp.now() }, { merge: true });
    }

    // Create order ID now so we can tie PI metadata -> order
    const orderRef = db.collection('orders').doc();
    const orderId = orderRef.id;

    logInfo('Creating wire transfer PaymentIntent', {
      route: '/api/stripe/wire/create-intent',
      orderId,
      listingId,
      buyerId,
      amountCents,
      stripeCustomerId,
    });

    const pi = await stripe.paymentIntents.create({
      amount: amountCents,
      currency: 'usd',
      customer: stripeCustomerId,
      payment_method_types: ['customer_balance'],
      payment_method_data: { type: 'customer_balance' },
      payment_method_options: {
        customer_balance: {
          funding_type: 'bank_transfer',
          bank_transfer: { type: 'us_bank_transfer' },
        },
      } as any,
      confirm: true,
      description: `Wire transfer for listing ${listingId}`,
      metadata: {
        orderId,
        listingId,
        buyerId,
        sellerId: listingData.sellerId,
        sellerStripeAccountId: String(sellerStripeAccountId || ''),
        platformFee: String(platformFeeCents),
        sellerAmount: String(sellerAmountCents),
        paymentMethod: 'wire',
        ...(offerId ? { offerId: String(offerId), acceptedAmount: String(purchaseAmountUsd) } : {}),
      },
    });

    const instructions = formatWireInstructionsFromPaymentIntent(pi);
    if (!instructions.reference) {
      logWarn('Wire PaymentIntent created but missing reference instructions', {
        route: '/api/stripe/wire/create-intent',
        orderId,
        paymentIntentId: pi.id,
      });
    }

    const now = new Date();
    const transferPermitRequired = listingData.category === 'whitetail_breeder';

    // Create order (awaiting_wire) and reserve listing
    await db.runTransaction(async (tx) => {
      const latestListing = await tx.get(listingRef);
      if (!latestListing.exists) throw new Error('Listing not found');
      const l = latestListing.data() as any;
      if (l.purchaseReservedByOrderId) throw new Error('Listing is reserved pending payment confirmation');

      tx.set(orderRef, {
        listingId,
        buyerId,
        sellerId: listingData.sellerId,
        ...(offerId ? { offerId: String(offerId) } : {}),
        amount: amountCents / 100,
        platformFee: platformFeeCents / 100,
        sellerAmount: sellerAmountCents / 100,
        status: 'awaiting_wire',
        paymentMethod: 'wire',
        stripePaymentIntentId: pi.id,
        sellerStripeAccountId: sellerStripeAccountId,
        paidAt: null,
        disputeDeadlineAt: null,
        createdAt: now,
        updatedAt: now,
        lastUpdatedByRole: 'admin',
        // Compliance fields
        transferPermitRequired,
        ...(transferPermitRequired ? { transferPermitStatus: 'none' as const } : {}),
        // Wire reconciliation helpers
        wireReference: instructions.reference || null,
        wireInstructions: instructions,
      });

      tx.set(
        listingRef,
        {
          purchaseReservedByOrderId: orderId,
          purchaseReservedAt: now,
          updatedAt: now,
        },
        { merge: true }
      );

      if (offerId && offerRef) {
        tx.set(
          offerRef,
          {
            orderId,
            updatedAt: Timestamp.now(),
          },
          { merge: true }
        );
      }
    });

    await createAuditLog(db, {
      actorUid: buyerId,
      actorRole: 'buyer',
      actionType: 'wire_payment_intent_created',
      orderId,
      listingId,
      beforeState: {},
      afterState: { status: 'awaiting_wire', paymentMethod: 'wire' },
      metadata: { paymentIntentId: pi.id, reference: instructions.reference || null, offerId: offerId ? String(offerId) : null },
      source: 'buyer_ui',
    });

    return NextResponse.json({
      orderId,
      paymentIntentId: pi.id,
      paymentMethod: 'wire',
      status: 'awaiting_wire',
      instructions,
    });
  } catch (error: any) {
    // Surface actionable Stripe errors to the client (without leaking secrets).
    const stripeErr: any = error?.type || error?.raw ? error : null;
    const stripePayload = stripeErr
      ? {
          type: stripeErr.type || stripeErr.raw?.type,
          code: stripeErr.code || stripeErr.raw?.code,
          decline_code: stripeErr.decline_code || stripeErr.raw?.decline_code,
          message: stripeErr.message || stripeErr.raw?.message,
          statusCode: stripeErr.statusCode || stripeErr.raw?.statusCode,
          requestId: stripeErr.requestId || stripeErr.raw?.requestId,
          doc_url: stripeErr.doc_url || stripeErr.raw?.doc_url,
        }
      : null;

    console.error('Error creating wire transfer intent:', {
      message: String(error?.message || error),
      stripe: stripePayload || undefined,
    });

    // Common actionable message for misconfigured bank transfer rails.
    const looksLikeBankTransferNotEnabled =
      typeof stripePayload?.message === 'string' &&
      /customer_balance|bank_transfer|us_bank_transfer|financial_addresses|display_bank_transfer_instructions/i.test(stripePayload.message);

    return NextResponse.json(
      {
        error: 'Failed to create wire transfer instructions',
        message:
          (looksLikeBankTransferNotEnabled
            ? 'Wire/Bank transfer is not enabled or not configured on the Stripe account. Please enable Customer Balance â†’ Bank transfer (US bank transfer) in Stripe and try again.'
            : error?.message) || 'Unknown error',
        stripe: stripePayload || undefined,
      },
      { status: 500 }
    );
  }
}

