/**
 * POST /api/stripe/wire/create-intent
 *
 * Creates a Stripe PaymentIntent configured for bank transfer instructions (wire/bank transfer),
 * creates an Order in Firestore with status awaiting_wire, and reserves the listing.
 *
 * IMPORTANT:
 * - This preserves payout-hold model: funds land in platform Stripe balance, order becomes paid_held only via Stripe webhook.
 * - No off-platform payments; wire details are generated by Stripe.
 */

import { FieldValue, Timestamp } from 'firebase-admin/firestore';
import { getStorage } from 'firebase-admin/storage';
import Stripe from 'stripe';
import { stripe, calculatePlatformFee, isStripeConfigured } from '@/lib/stripe/config';
import { validateRequest, createWireIntentSchema } from '@/lib/validation/api-schemas';
import { checkRateLimitByKey, rateLimitMiddleware, RATE_LIMITS } from '@/lib/rate-limit';
import { createAuditLog } from '@/lib/audit/logger';
import { logInfo, logWarn } from '@/lib/monitoring/logger';
import { getAdminAuth, getAdminDb } from '@/lib/firebase/admin';
import { containsProhibitedKeywords } from '@/lib/compliance/validation';
import { formatWireInstructionsFromPaymentIntent } from '@/lib/stripe/wire';
import { normalizeCategory } from '@/lib/listings/normalizeCategory';
import { getCategoryRequirements, isTexasOnlyCategory } from '@/lib/compliance/requirements';
import { ensureBillOfSaleForOrder } from '@/lib/orders/billOfSale';
import { recomputeOrderComplianceDocsStatus } from '@/lib/orders/complianceDocsStatus';
import { LEGAL_VERSIONS } from '@/lib/legal/versions';
import { coerceDurationDays, computeEndAt, toMillisSafe } from '@/lib/listings/duration';

export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

function json(body: any, init?: { status?: number; headers?: Record<string, string> | Headers }) {
  const headers =
    init?.headers instanceof Headers
      ? Object.fromEntries(init.headers.entries())
      : (init?.headers as Record<string, string> | undefined);

  return new Response(JSON.stringify(body), {
    status: init?.status ?? 200,
    headers: {
      'content-type': 'application/json',
      ...(headers || {}),
    },
  });
}

// Small shim so we don't have to rewrite every `NextResponse.json(...)` call in this file.
const NextResponse = { json };

export async function POST(request: Request) {
  try {
    let auth: ReturnType<typeof getAdminAuth>;
    let db: ReturnType<typeof getAdminDb>;
    try {
      auth = getAdminAuth();
      db = getAdminDb();
    } catch (e: any) {
      logWarn('Firebase Admin init failed in /api/stripe/wire/create-intent', {
        code: e?.code,
        message: e?.message,
        missing: e?.missing,
      });
      return NextResponse.json(
        {
          error: 'Server is not configured for payments yet',
          code: e?.code || 'FIREBASE_ADMIN_INIT_FAILED',
          message: e?.message || 'Failed to initialize Firebase Admin SDK',
          missing: e?.missing || undefined,
        },
        { status: 503 }
      );
    }

    if (!isStripeConfigured() || !stripe) {
      return NextResponse.json(
        { error: 'Stripe is not configured. Please set STRIPE_SECRET_KEY environment variable.' },
        { status: 503 }
      );
    }

    const authHeader = request.headers.get('authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return NextResponse.json({ error: 'Unauthorized - Missing or invalid authorization header' }, { status: 401 });
    }

    const token = authHeader.split('Bearer ')[1];
    let decodedToken;
    try {
      decodedToken = await auth.verifyIdToken(token);
    } catch {
      return NextResponse.json({ error: 'Unauthorized - Invalid token' }, { status: 401 });
    }

    const buyerId = decodedToken.uid;

    // Wire requires verified email (and authentication).
    const buyerRecord = await auth.getUser(buyerId).catch(() => null as any);
    if (buyerRecord?.emailVerified !== true) {
      return NextResponse.json(
        {
          error: 'Email verification required',
          code: 'EMAIL_NOT_VERIFIED',
          message: 'Please verify your email address before using wire transfer.',
        },
        { status: 403 }
      );
    }

    let body: any;
    try {
      body = await request.json();
    } catch {
      return NextResponse.json({ error: 'Invalid JSON in request body' }, { status: 400 });
    }

    const validation = validateRequest(createWireIntentSchema, body);
    if (!validation.success) {
      return NextResponse.json({ error: validation.error, details: validation.details?.errors }, { status: 400 });
    }

    const { listingId, offerId, buyerAcksAnimalRisk } = validation.data as any;

    // Rate limiting (post-auth, keyed per user+listing) to avoid shared-IP false positives.
    const rlKey = `wire:user:${buyerId}:listing:${String(listingId || 'unknown')}`;
    const rl = await checkRateLimitByKey(rlKey, RATE_LIMITS.checkout);
    if (!rl.allowed) {
      return NextResponse.json(
        { error: rl.error || 'Too many requests. Please try again later.', retryAfter: rl.retryAfter },
        { status: rl.status ?? 429, headers: { 'Retry-After': String(rl.retryAfter) } }
      );
    }

    // Get listing
    const listingRef = db.collection('listings').doc(listingId);
    const listingDoc = await listingRef.get();
    if (!listingDoc.exists) return NextResponse.json({ error: 'Listing not found' }, { status: 404 });
    const listingData = listingDoc.data()!;

    // Classified listings are deprecated (no wire checkout).
    if (String((listingData as any)?.type || '') === 'classified') {
      return NextResponse.json(
        { error: 'This listing type is no longer supported for checkout', code: 'CLASSIFIED_DISABLED' },
        { status: 400 }
      );
    }

    // Listing duration guard (server authoritative) for non-auctions.
    if (String((listingData as any)?.type || '') !== 'auction') {
      const nowMs = Date.now();
      const endMsDirect = toMillisSafe((listingData as any)?.endAt) ?? toMillisSafe((listingData as any)?.endsAt);
      const startMs =
        toMillisSafe((listingData as any)?.startAt) ??
        toMillisSafe((listingData as any)?.publishedAt) ??
        toMillisSafe((listingData as any)?.createdAt);
      const durationDays = coerceDurationDays((listingData as any)?.durationDays, 7);
      const endMs = endMsDirect ?? (typeof startMs === 'number' ? computeEndAt(startMs, durationDays) : null);
      if ((listingData as any)?.status !== 'active') {
        return NextResponse.json({ error: 'Listing is not available for purchase' }, { status: 409 });
      }
      if (typeof endMs === 'number' && endMs <= nowMs) {
        return NextResponse.json(
          { error: 'Listing has ended', code: 'LISTING_ENDED', message: 'This listing has ended.' },
          { status: 409 }
        );
      }
    }

    // Canonicalize category (fail closed)
    let listingCategory: any;
    try {
      listingCategory = normalizeCategory((listingData as any).category);
    } catch {
      return NextResponse.json({ error: 'Invalid listing category' }, { status: 400 });
    }

    const categoryReq = getCategoryRequirements(listingCategory as any);
    if (categoryReq.isAnimal && buyerAcksAnimalRisk !== true) {
      return NextResponse.json(
        {
          error: 'Buyer acknowledgment required',
          code: 'BUYER_ACK_REQUIRED',
          message:
            'Before purchasing an animal listing, you must acknowledge live-animal risk, seller-only representations, and that the platform does not take custody.',
        },
        { status: 400 }
      );
    }

    // If a high-ticket checkout is pending for this listing, block additional checkouts
    if (listingData.purchaseReservedByOrderId) {
      return NextResponse.json(
        { error: 'Listing is reserved pending payment confirmation. Please try again later.' },
        { status: 409 }
      );
    }

    // Best Offer checkout path (accepted offer -> pay at agreed price)
    let offerData: any = null;
    let offerRef: any = null;
    if (offerId) {
      offerRef = db.collection('offers').doc(String(offerId));
      const offerSnap = await offerRef.get();
      if (!offerSnap.exists) return NextResponse.json({ error: 'Offer not found' }, { status: 404 });
      offerData = offerSnap.data();

      if (offerData?.listingId !== listingId) return NextResponse.json({ error: 'Offer does not match listing' }, { status: 400 });
      if (offerData?.buyerId !== buyerId) return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
      if (offerData?.status !== 'accepted') return NextResponse.json({ error: 'Offer is not accepted' }, { status: 400 });
      if (listingData?.offerReservedByOfferId && listingData.offerReservedByOfferId !== String(offerId)) {
        return NextResponse.json({ error: 'Listing is reserved by another offer' }, { status: 409 });
      }
      if (!listingData?.offerReservedByOfferId) {
        return NextResponse.json({ error: 'Listing is not reserved for this offer' }, { status: 409 });
      }
      if (listingData?.sellerId !== offerData?.sellerId) return NextResponse.json({ error: 'Offer seller mismatch' }, { status: 400 });
    }

    if (listingData.status !== 'active') {
      return NextResponse.json({ error: 'Listing is not available for purchase' }, { status: 400 });
    }

    // If listing is reserved by an accepted offer, block non-offer checkout
    if (!offerId && listingData.offerReservedByOfferId) {
      return NextResponse.json({ error: 'Listing is reserved by an accepted offer' }, { status: 409 });
    }

    // Determine purchase amount (server authoritative)
    let purchaseAmountUsd: number;
    if (offerId) {
      if (listingData.type !== 'fixed' && listingData.type !== 'classified') {
        return NextResponse.json({ error: 'Offer checkout is only supported for fixed/classified listings' }, { status: 400 });
      }
      const accepted = Number(offerData?.acceptedAmount ?? offerData?.currentAmount);
      if (!Number.isFinite(accepted) || accepted <= 0) {
        return NextResponse.json({ error: 'Offer has an invalid accepted amount' }, { status: 400 });
      }
      purchaseAmountUsd = accepted;
    } else if (listingData.type === 'fixed') {
      if (!listingData.price || listingData.price <= 0) return NextResponse.json({ error: 'Listing does not have a valid price' }, { status: 400 });
      purchaseAmountUsd = listingData.price;
    } else if (listingData.type === 'auction') {
      // Verify auction has ended
      if (listingData.endsAt) {
        const endsAt = listingData.endsAt.toDate();
        if (endsAt.getTime() > Date.now()) {
          return NextResponse.json({ error: 'Auction has not ended yet' }, { status: 400 });
        }
      }
      const bidsRef = db.collection('bids');
      const winningBidQuery = await bidsRef.where('listingId', '==', listingId).orderBy('amount', 'desc').limit(1).get();
      if (winningBidQuery.empty) return NextResponse.json({ error: 'No bids found for this auction' }, { status: 400 });
      const winningBidData = winningBidQuery.docs[0]!.data();
      if (winningBidData.bidderId !== buyerId) {
        return NextResponse.json({ error: 'You are not the winning bidder' }, { status: 403 });
      }
      purchaseAmountUsd = Number(winningBidData.amount);
    } else if (listingData.type === 'classified') {
      if (!listingData.price || listingData.price <= 0) return NextResponse.json({ error: 'Listing does not have a valid price' }, { status: 400 });
      purchaseAmountUsd = listingData.price;
    } else {
      return NextResponse.json({ error: 'This listing type does not support wire transfer' }, { status: 400 });
    }

    const amountCents = Math.round(purchaseAmountUsd * 100);

    // NOTE: We intentionally do NOT enforce a hard minimum for wire here.
    // If product policy changes later, gate it here server-side.

    // Prevent buying own listing
    if (listingData.sellerId === buyerId) {
      return NextResponse.json({ error: 'You cannot purchase your own listing' }, { status: 400 });
    }

    // TX-only enforcement for configured categories (server authoritative)
    if (isTexasOnlyCategory(listingCategory)) {
      if (listingData.location?.state !== 'TX') {
        return NextResponse.json({ error: 'Animal listings must be located in Texas.' }, { status: 400 });
      }
      const buyerRef = db.collection('users').doc(buyerId);
      const buyerDoc = await buyerRef.get();
      if (!buyerDoc.exists) return NextResponse.json({ error: 'Buyer profile not found. Please complete your profile.' }, { status: 400 });
      const buyerData = buyerDoc.data()!;
      const buyerState = buyerData.profile?.location?.state;
      if (!buyerState || buyerState !== 'TX') {
        return NextResponse.json(
          { error: 'Only Texas residents can purchase animal listings. Please update your profile location to Texas.', code: 'TEXAS_ONLY_REQUIRED' },
          { status: 400 }
        );
      }
      if (containsProhibitedKeywords(listingData.title) || containsProhibitedKeywords(listingData.description)) {
        return NextResponse.json({ error: 'Listing contains prohibited content and cannot be purchased.' }, { status: 400 });
      }
    }

    // Seller readiness checks (payout-ready)
    const sellerRef = db.collection('users').doc(listingData.sellerId);
    const sellerDoc = await sellerRef.get();
    if (!sellerDoc.exists) return NextResponse.json({ error: 'Seller not found' }, { status: 404 });
    const sellerData = sellerDoc.data()!;
    const sellerStripeAccountId = sellerData.stripeAccountId;
    const isPayoutReady =
      sellerStripeAccountId &&
      (sellerData.chargesEnabled ?? false) &&
      (sellerData.payoutsEnabled ?? false) &&
      (sellerData.stripeDetailsSubmitted ?? false) &&
      (sellerData.stripeOnboardingStatus || 'not_started') === 'complete';
    if (!isPayoutReady) {
      return NextResponse.json({ error: 'Seller is not ready to receive payouts yet. Please try later.', code: 'SELLER_NOT_PAYOUT_READY' }, { status: 400 });
    }

    // Fees (flat)
    const platformFeeCents = calculatePlatformFee(amountCents);
    const sellerAmountCents = amountCents - platformFeeCents;

    // Ensure Stripe Customer exists (required for customer_balance bank transfer instructions)
    const buyerUserRef = db.collection('users').doc(buyerId);
    const buyerUserDoc = await buyerUserRef.get();
    const buyerUserData = buyerUserDoc.exists ? (buyerUserDoc.data() as any) : {};
    let stripeCustomerId: string | undefined = buyerUserData?.stripeCustomerId;

    if (!stripeCustomerId) {
      const customer = await stripe.customers.create({
        email: decodedToken.email || buyerRecord?.email || undefined,
        metadata: { buyerId },
      });
      stripeCustomerId = customer.id;
      // Best-effort persist to user doc (no undefined writes)
      await buyerUserRef.set({ stripeCustomerId, updatedAt: Timestamp.now() }, { merge: true });
    }

    // Create order ID now so we can tie PI metadata -> order
    const orderRef = db.collection('orders').doc();
    const orderId = orderRef.id;

    logInfo('Creating wire transfer PaymentIntent', {
      route: '/api/stripe/wire/create-intent',
      orderId,
      listingId,
      buyerId,
      amountCents,
      stripeCustomerId,
    });

    const pi = await stripe.paymentIntents.create({
      amount: amountCents,
      currency: 'usd',
      customer: stripeCustomerId,
      payment_method_types: ['customer_balance'],
      payment_method_data: { type: 'customer_balance' },
      payment_method_options: {
        customer_balance: {
          funding_type: 'bank_transfer',
          bank_transfer: { type: 'us_bank_transfer' },
        },
      } as any,
      confirm: true,
      description: `Wire transfer for listing ${listingId}`,
      metadata: {
        orderId,
        listingId,
        buyerId,
        sellerId: listingData.sellerId,
        sellerStripeAccountId: String(sellerStripeAccountId || ''),
        platformFee: String(platformFeeCents),
        sellerAmount: String(sellerAmountCents),
        paymentMethod: 'wire',
        ...(offerId ? { offerId: String(offerId), acceptedAmount: String(purchaseAmountUsd) } : {}),
      },
    });

    const instructions = formatWireInstructionsFromPaymentIntent(pi);
    if (!instructions.reference) {
      logWarn('Wire PaymentIntent created but missing reference instructions', {
        route: '/api/stripe/wire/create-intent',
        orderId,
        paymentIntentId: pi.id,
      });
    }

    const now = new Date();
    const transferPermitRequired = listingCategory === 'whitetail_breeder';

    // Create order (awaiting_wire) and reserve listing
    await db.runTransaction(async (tx) => {
      const latestListing = await tx.get(listingRef);
      if (!latestListing.exists) throw new Error('Listing not found');
      const l = latestListing.data() as any;
      if (l.purchaseReservedByOrderId) throw new Error('Listing is reserved pending payment confirmation');

      // Public-safe snapshots for fast "My Purchases" rendering (avoid N+1 listing reads).
      const photos = Array.isArray(l?.photos) ? l.photos : [];
      const sortedPhotos = photos.length
        ? [...photos].sort((a: any, b: any) => Number(a?.sortOrder || 0) - Number(b?.sortOrder || 0))
        : [];
      const coverPhotoUrl =
        (sortedPhotos.find((p: any) => typeof p?.url === 'string' && p.url.trim())?.url as string | undefined) ||
        (Array.isArray(l?.images) ? (l.images.find((u: any) => typeof u === 'string' && u.trim()) as string | undefined) : undefined);

      const city = l?.location?.city ? String(l.location.city) : '';
      const state = l?.location?.state ? String(l.location.state) : '';
      const locationLabel = city && state ? `${city}, ${state}` : state || '';

      const sellerDisplayName =
        String(l?.sellerSnapshot?.displayName || '').trim() ||
        String(l?.sellerSnapshot?.name || '').trim() ||
        'Seller';
      const sellerPhotoURL =
        typeof l?.sellerSnapshot?.photoURL === 'string' && l.sellerSnapshot.photoURL.trim()
          ? String(l.sellerSnapshot.photoURL)
          : undefined;

      tx.set(orderRef, {
        listingId,
        buyerId,
        sellerId: listingData.sellerId,
        // Redundant but useful: admin tooling often uses listingTitle for display.
        listingTitle: String(l?.title || listingData?.title || 'Listing'),
        listingSnapshot: {
          listingId,
          title: String(l?.title || listingData?.title || 'Listing'),
          type: l?.type ? String(l.type) : undefined,
          category: l?.category ? String(l.category) : undefined,
          ...(coverPhotoUrl ? { coverPhotoUrl: String(coverPhotoUrl) } : {}),
          ...(locationLabel ? { locationLabel } : {}),
        },
        sellerSnapshot: {
          sellerId: String(listingData.sellerId || ''),
          displayName: sellerDisplayName,
          ...(sellerPhotoURL ? { photoURL: sellerPhotoURL } : {}),
        },
        ...(offerId ? { offerId: String(offerId) } : {}),
        amount: amountCents / 100,
        platformFee: platformFeeCents / 100,
        sellerAmount: sellerAmountCents / 100,
        status: 'awaiting_wire',
        paymentMethod: 'wire',
        stripePaymentIntentId: pi.id,
        sellerStripeAccountId: sellerStripeAccountId,
        paidAt: null,
        disputeDeadlineAt: null,
        timeline: [
          {
            id: `ORDER_PLACED:${orderId}`,
            type: 'ORDER_PLACED',
            label: 'Order placed',
            timestamp: Timestamp.fromDate(now),
            actor: 'buyer',
            visibility: 'buyer',
            meta: { paymentMethod: 'wire' },
          },
        ],
        ...(categoryReq.isAnimal
          ? {
              buyerAcksAnimalRisk: true,
              buyerAcksAnimalRiskAt: now,
              buyerAcksAnimalRiskVersion: LEGAL_VERSIONS.buyerAcknowledgment.version,
            }
          : {}),
        createdAt: now,
        updatedAt: now,
        lastUpdatedByRole: 'admin',
        // Compliance fields
        transferPermitRequired,
        ...(transferPermitRequired ? { transferPermitStatus: 'none' as const } : {}),
        // Wire reconciliation helpers
        wireReference: instructions.reference || null,
        wireInstructions: instructions,
      });

      tx.set(
        listingRef,
        {
          purchaseReservedByOrderId: orderId,
          purchaseReservedAt: now,
          updatedAt: now,
        },
        { merge: true }
      );

      if (offerId && offerRef) {
        tx.set(
          offerRef,
          {
            orderId,
            updatedAt: Timestamp.now(),
          },
          { merge: true }
        );
      }
    });

    // For categories that require it (e.g. horses), generate Bill of Sale (idempotent)
    // If BOS generation fails, rollback reservation best-effort and surface an actionable error.
    const rollbackReservationBestEffort = async () => {
      await Promise.allSettled([
        listingRef.set(
          {
            purchaseReservedByOrderId: FieldValue.delete(),
            purchaseReservedAt: FieldValue.delete(),
            updatedAt: Timestamp.now(),
          },
          { merge: true }
        ),
        orderRef.delete().catch(() => null),
      ]);
    };

    try {
      const bucket = getStorage().bucket();
      const nowTs = Timestamp.now();
      const buyerUserDoc2 = await db.collection('users').doc(buyerId).get();
      const buyerData2 = buyerUserDoc2.exists ? (buyerUserDoc2.data() as any) : {};

      const sellerUserDoc2 = await db.collection('users').doc(String(listingData.sellerId)).get();
      const sellerData2 = sellerUserDoc2.exists ? (sellerUserDoc2.data() as any) : {};

      const bos = await ensureBillOfSaleForOrder({
        db,
        bucket,
        orderId,
        listing: {
          id: listingId,
          title: String(listingData.title || ''),
          category: listingCategory,
          attributes: (listingData as any).attributes || null,
        },
        orderAmountUsd: Number(amountCents / 100),
        buyer: {
          uid: buyerId,
          fullName: String(buyerData2?.profile?.displayName || buyerData2?.profile?.name || decodedToken?.name || decodedToken?.email || 'Buyer'),
          email: decodedToken?.email || buyerRecord?.email || null,
          phoneNumber: buyerRecord?.phoneNumber || null,
          location: {
            address: buyerData2?.profile?.location?.address || null,
            city: String(buyerData2?.profile?.location?.city || ''),
            state: String(buyerData2?.profile?.location?.state || ''),
            zip: String(buyerData2?.profile?.location?.zip || ''),
          },
        },
        seller: {
          uid: String(listingData.sellerId),
          fullName: String(sellerData2?.profile?.displayName || sellerData2?.profile?.name || 'Seller'),
          email: sellerData2?.profile?.email || null,
          phoneNumber: sellerData2?.profile?.phoneNumber || null,
          location: {
            address: sellerData2?.profile?.location?.address || null,
            city: String(sellerData2?.profile?.location?.city || ''),
            state: String(sellerData2?.profile?.location?.state || ''),
            zip: String(sellerData2?.profile?.location?.zip || ''),
          },
        },
        now: nowTs as any,
      });

      if (!bos.ok) {
        await rollbackReservationBestEffort();
        return NextResponse.json(
          { error: bos.message, code: bos.code, missing: bos.missing || undefined },
          { status: 400 }
        );
      }

      await recomputeOrderComplianceDocsStatus({ db, orderId });
    } catch (e: any) {
      await rollbackReservationBestEffort();
      return NextResponse.json(
        { error: 'Failed to prepare required order documents', message: e?.message || 'Unknown error' },
        { status: 500 }
      );
    }

    await createAuditLog(db, {
      actorUid: buyerId,
      actorRole: 'buyer',
      actionType: 'wire_payment_intent_created',
      orderId,
      listingId,
      beforeState: {},
      afterState: { status: 'awaiting_wire', paymentMethod: 'wire' },
      metadata: { paymentIntentId: pi.id, reference: instructions.reference || null, offerId: offerId ? String(offerId) : null },
      source: 'buyer_ui',
    });

    return NextResponse.json({
      orderId,
      paymentIntentId: pi.id,
      paymentMethod: 'wire',
      status: 'awaiting_wire',
      instructions,
    });
  } catch (error: any) {
    // Surface actionable Stripe errors to the client (without leaking secrets).
    const stripeErr: any = error?.type || error?.raw ? error : null;
    const stripePayload = stripeErr
      ? {
          type: stripeErr.type || stripeErr.raw?.type,
          code: stripeErr.code || stripeErr.raw?.code,
          decline_code: stripeErr.decline_code || stripeErr.raw?.decline_code,
          message: stripeErr.message || stripeErr.raw?.message,
          statusCode: stripeErr.statusCode || stripeErr.raw?.statusCode,
          requestId: stripeErr.requestId || stripeErr.raw?.requestId,
          doc_url: stripeErr.doc_url || stripeErr.raw?.doc_url,
        }
      : null;

    console.error('Error creating wire transfer intent:', {
      message: String(error?.message || error),
      stripe: stripePayload || undefined,
    });

    // Common actionable message for misconfigured bank transfer rails.
    const looksLikeBankTransferNotEnabled =
      typeof stripePayload?.message === 'string' &&
      /customer_balance|bank_transfer|us_bank_transfer|financial_addresses|display_bank_transfer_instructions/i.test(stripePayload.message);

    return NextResponse.json(
      {
        error: 'Failed to create wire transfer instructions',
        message:
          (looksLikeBankTransferNotEnabled
            ? 'Wire/Bank transfer is not enabled or not configured on the Stripe account. Please enable Customer Balance â†’ Bank transfer (US bank transfer) in Stripe and try again.'
            : error?.message) || 'Unknown error',
        stripe: stripePayload || undefined,
      },
      { status: 500 }
    );
  }
}

