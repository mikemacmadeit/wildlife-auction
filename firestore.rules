rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Helper function to check if user owns a document
    // (keep only if/when used in rules below; otherwise remove to reduce warnings)
    // function isOwner(userId) {
    //   return isAuthenticated() && request.auth.uid == userId;
    // }
    
    // Helper function to check if user is an admin
    // Checks the auth token role claim first (fast, no get() call), then falls back to reading user document
    function isAdmin() {
      return isAuthenticated() && (
        // Check token first (fast, no get() call)
        request.auth.token.role == 'admin' ||
        request.auth.token.role == 'super_admin' ||
        // Fallback to user document (slower, but necessary if token doesn't have role)
        (exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
         (get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin' ||
          get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'super_admin'))
      );
    }
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Allow read: only owner or admin (user docs may contain sensitive fields)
      allow read: if isAuthenticated() && (request.auth.uid == userId || isAdmin());
      
      // Allow create: if authenticated and creating own document
      allow create: if isAuthenticated() && request.auth.uid == userId &&
        // Prevent self-assigning admin/billing fields at create time
        !request.resource.data.keys().hasAny([
          'subscriptionPlan',
          'stripeCustomerId',
          'stripeSubscriptionId',
          'subscriptionStatus',
          'subscriptionCurrentPeriodEnd',
          'subscriptionCancelAtPeriodEnd',
          'adminPlanOverride',
          'adminFeeOverride',
          'adminOverrideReason',
          'adminOverrideBy',
          'adminOverrideAt',
          'role',
          'superAdmin',
          'stripeAccountId',
          'stripeOnboardingStatus',
          'chargesEnabled',
          'payoutsEnabled',
          'stripeDetailsSubmitted'
        ]) &&
        // If tier is included at create time, it must be Standard
        (
          !request.resource.data.keys().hasAny(['subscriptionTier']) ||
          request.resource.data.subscriptionTier == 'standard'
        );
      
      // Allow update: if authenticated and updating own document
      allow update: if isAuthenticated() && request.auth.uid == userId &&
        // Prevent client-side mutation of billing/admin/tier fields (must be server-controlled)
        !request.resource.data.diff(resource.data).changedKeys().hasAny([
          'subscriptionTier',
          'subscriptionPlan',
          'stripeCustomerId',
          'stripeSubscriptionId',
          'subscriptionStatus',
          'subscriptionCurrentPeriodEnd',
          'subscriptionCancelAtPeriodEnd',
          'adminPlanOverride',
          'adminFeeOverride',
          'adminOverrideReason',
          'adminOverrideBy',
          'adminOverrideAt',
          'role',
          'superAdmin',
          'stripeAccountId',
          'stripeOnboardingStatus',
          'chargesEnabled',
          'payoutsEnabled',
          'stripeDetailsSubmitted'
        ]);
      
      // Allow delete: if authenticated and deleting own document
      allow delete: if isAuthenticated() && request.auth.uid == userId;
    }

    // ============================================
    // PUBLIC PROFILES (SAFE FIELDS ONLY)
    // ============================================
    // This collection is intended for public/marketplace display (seller cards, bidder names, etc.).
    // Never store email, phone, Stripe IDs, or billing/admin fields here.
    match /publicProfiles/{userId} {
      // Read is public so listing pages can show seller info to logged-out users.
      allow read: if true;

      // Owner can upsert their public profile doc.
      // We restrict which keys can be written so sensitive fields can't be smuggled in.
      allow create, update: if isAuthenticated() && request.auth.uid == userId &&
        !request.resource.data.keys().hasAny([
          'email',
          'phoneNumber',
          'stripeCustomerId',
          'stripeAccountId',
          'stripeSubscriptionId',
          'subscriptionPlan',
          'subscriptionStatus',
          'role',
          'superAdmin'
        ]);

      allow delete: if false;
    }

    // ============================================
    // USER PHOTOS (Uploads Library)
    // ============================================
    // /users/{uid}/photos/{photoId}
    match /users/{userId}/photos/{photoId} {
      allow read, create, update, delete: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // ============================================
    // LISTINGS COLLECTION
    // ============================================
    match /listings/{listingId} {
      // Allow read:
      //   - If listing status is 'active' (PUBLIC - anyone can see active listings)
      //   - OR if user is authenticated and is the seller (seller can see their own listings regardless of status)
      //   - OR if user is an admin (admins can see all listings including draft/pending)
      // Note: For queries, sellers can query their own listings (where sellerId == auth.uid)
      //       and the rule evaluates per-document, so each document must pass this check
      allow read: if (resource.data.status == 'active' || resource.data.status == 'sold') || 
                    (isAuthenticated() && resource.data.sellerId == request.auth.uid) ||
                    isAdmin();
      
      // Allow create: if authenticated and sellerId matches the authenticated user
      // Validation: status must be 'draft', sellerId and createdBy must match auth.uid
      allow create: if isAuthenticated() && 
        request.resource.data.sellerId == request.auth.uid &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.status == 'draft' &&
        // Draft-first UX: allow creating a draft before all listing details exist.
        // Require only identity + audit fields; enforce deeper validation at publish time (server route).
        request.resource.data.keys().hasAll(['status', 'sellerId', 'createdBy', 'createdAt', 'updatedAt']) &&
        // Server-only reservation fields cannot be set by clients at create time
        !request.resource.data.keys().hasAny([
          'offerReservedByOfferId',
          'offerReservedAt',
          'purchaseReservedByOrderId',
          'purchaseReservedAt'
        ]) &&
        // Prevent setting sellerId to different value
        request.resource.data.sellerId == request.auth.uid;
      
      // Allow update: if authenticated and user is the seller OR if user is an admin
      // Validation: cannot change sellerId, status transitions are allowed
      // Admins can update listings for approval/rejection purposes
      // Compliance: Only admins can change complianceStatus to approved/rejected
      allow update: if (isAuthenticated() && resource.data.sellerId == request.auth.uid && 
                       // Sellers cannot mutate immutable identity/audit fields
                       !request.resource.data.diff(resource.data).changedKeys().hasAny(['sellerId', 'createdBy', 'createdAt']) &&
                       // Sellers cannot change complianceStatus to approved/rejected
                       (request.resource.data.complianceStatus == null || 
                        request.resource.data.complianceStatus == resource.data.complianceStatus ||
                        request.resource.data.complianceStatus == 'pending_review') &&
                       // Server-only reservation fields: sellers can't set/clear/mutate them
                       !request.resource.data.diff(resource.data).changedKeys().hasAny([
                         'offerReservedByOfferId',
                         'offerReservedAt',
                         'purchaseReservedByOrderId',
                         'purchaseReservedAt'
                       ]) &&
                       // Whitetail breeder: block status transitions to pending/active if attestation missing or permit expired
                       (
                         resource.data.category != 'whitetail_breeder' ||
                         (
                           // If status is not changing, don't block edits (do not auto-disable existing active listings)
                           request.resource.data.status == resource.data.status ||
                           (
                             // If status is changing to pending/active, enforce current (non-expired) permit + attestation
                             (request.resource.data.status == 'pending' || request.resource.data.status == 'active') &&
                             request.resource.data.sellerAttestationAccepted == true &&
                             request.resource.data.sellerAttestationAcceptedAt is timestamp &&
                             request.resource.data.attributes.tpwdPermitExpirationDate is timestamp &&
                             request.resource.data.attributes.tpwdPermitExpirationDate >= request.time
                           )
                         )
                       )) ||
                    (isAdmin() && 
                     // Admins can change complianceStatus
                     true);
      
      // Allow delete: if authenticated and user is the seller
      allow delete: if isAuthenticated() && resource.data.sellerId == request.auth.uid;
      
      // Documents subcollection
      match /documents/{documentId} {
        // Helper to check if user owns the parent listing
        function isListingOwner() {
          return isAuthenticated() && 
                 get(/databases/$(database)/documents/listings/$(listingId)).data.sellerId == request.auth.uid;
        }
        
        // Allow read: admin OR seller (owner of parent listing)
        // Check admin first (short-circuit evaluation)
        allow read: if isAuthenticated() && (
          isAdmin() || isListingOwner()
        );
        
        // Allow create: authenticated user (app logic ensures ownership)
        // Similar to storage rules - allows authenticated creates to handle:
        // 1. Cross-service rules setup
        // 2. Firestore propagation delays
        // 3. Document upload flow
        // The uploadedBy field ensures the document is linked to the correct user
        allow create: if isAuthenticated() && 
          request.resource.data.status == 'uploaded' &&
          request.resource.data.uploadedBy == request.auth.uid;
        
        // Allow update: only admin (for verification)
        allow update: if isAdmin() && 
          (request.resource.data.status == 'verified' || request.resource.data.status == 'rejected') &&
          request.resource.data.verifiedBy == request.auth.uid;
        
        // No delete allowed
        allow delete: if false;
      }

      // ============================================
      // AUCTION AUTO-BIDS (Proxy bidding max bids)
      // ============================================
      // /listings/{listingId}/autoBids/{userId}
      match /autoBids/{userId} {
        // Users may read *their own* max bid doc (for UI), but cannot write directly.
        allow read: if isAuthenticated() && request.auth.uid == userId;
        allow create: if false;
        allow update: if false;
        allow delete: if false;
      }
    }
    
    // ============================================
    // WATCHLIST COLLECTION (Subcollection under users)
    // ============================================
    // Using subcollection pattern: /users/{uid}/watchlist/{listingId}
    match /users/{userId}/watchlist/{listingId} {
      // Allow read: only the owner can read their watchlist
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // Phase 3A/B3 (scale + correctness): watch/unwatch mutations must go through
      // `POST /api/watchlist/toggle` (Admin SDK) so we can maintain:
      // - listings/{listingId}.watcherCount
      // - listings/{listingId}/watchers/{uid} reverse index
      // Allowing client writes here would cause drift under concurrency and break seller analytics.
      allow create: if false;
      allow delete: if false;
      
      // No updates allowed - watchlist entries are immutable
      allow update: if false;
    }

    // ============================================
    // SAVED SEARCHES (Subcollection under users)
    // ============================================
    // /users/{uid}/savedSearches/{searchId}
    match /users/{userId}/savedSearches/{searchId} {
      allow read, create, update, delete: if isAuthenticated() && request.auth.uid == userId;
    }

    // (Removed duplicate /users/{uid}/photos rules block; the canonical one lives above.)

    // ============================================
    // USER NOTIFICATIONS (Subcollection under users)
    // ============================================
    // /users/{uid}/notifications/{notificationId}
    match /users/{userId}/notifications/{notificationId} {
      // Allow read: only owner
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // Server-controlled creation (Admin SDK / processors)
      allow create: if false;

      // Allow update: only owner (mark read / clicked)
      allow update: if isAuthenticated() && request.auth.uid == userId;

      // No delete
      allow delete: if false;
    }

    // ============================================
    // USER HELP FLAGS (per-page help/tour state)
    // ============================================
    // /users/{uid}/helpFlags/{helpKey}
    match /users/{userId}/helpFlags/{helpKey} {
      allow read, create, update, delete: if isAuthenticated() && request.auth.uid == userId;
    }

    // ============================================
    // NOTIFICATION PREFERENCES (Subcollection under users)
    // ============================================
    // /users/{uid}/notificationPreferences/{docId}
    match /users/{userId}/notificationPreferences/{docId} {
      allow read, create, update, delete: if isAuthenticated() && request.auth.uid == userId;
    }

    // ============================================
    // PUSH TOKENS (Subcollection under users)
    // ============================================
    // /users/{uid}/pushTokens/{tokenId}
    match /users/{userId}/pushTokens/{tokenId} {
      allow read, create, update, delete: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // ============================================
    // BIDS COLLECTION
    // ============================================
    match /bids/{bidId} {
      // Allow read: authenticated users can read bids
      // (Bid history is public for active listings, but we require auth for now)
      allow read: if isAuthenticated();
      
      // P0: Bids must be placed via server-side API (Admin SDK) to enforce:
      // - listing status gates (active only)
      // - auction end time
      // - TX-only for animal categories
      // Client-side creates are disallowed to prevent bypass/spam.
      allow create: if false;
      
      // Bids are immutable - no updates or deletes allowed
      allow update: if false;
      allow delete: if false;
    }
    
    // ============================================
    // ORDERS COLLECTION
    // ============================================
    match /orders/{orderId} {
      // Allow read: buyer or seller can read their orders, OR if user is an admin
      allow read: if isAuthenticated() && (
        resource.data.buyerId == request.auth.uid ||
        resource.data.sellerId == request.auth.uid ||
        isAdmin()
      );
      
      // Allow create: server-side only (Admin SDK via Stripe webhooks / API routes).
      // Clients should never create orders directly.
      allow create: if false;
      
      // Allow update: buyer or seller can update their own orders (limited client-side actions), OR admin
      // IMPORTANT: payout + payment fields must be server-controlled.
      allow update: if isAuthenticated() && (
        (resource.data.buyerId == request.auth.uid &&
         // Buyer can only update status to buyer_confirmed/accepted (legacy) or disputed
         (request.resource.data.status == 'buyer_confirmed' || request.resource.data.status == 'accepted' || request.resource.data.status == 'disputed' || request.resource.data.status == 'ready_to_release') &&
         // Never allow buyer to mutate payout/payment/admin-controlled fields
         !request.resource.data.diff(resource.data).changedKeys().hasAny([
           'amount','platformFee','sellerAmount',
           'stripeCheckoutSessionId','stripePaymentIntentId','stripeTransferId','stripeRefundId',
           'sellerStripeAccountId','releasedBy','releasedAt','refundedBy','refundedAt','refundReason','refundAmount',
           'adminHold','adminHoldReason','adminActionNotes',
           'paidAt','disputeDeadlineAt','deliveryConfirmedAt','protectionStartAt','protectionEndsAt','payoutHoldReason',
           'protectedTransactionDaysSnapshot','protectedTermsVersion','chargebackStatus'
         ]) &&
         request.resource.data.buyerId == resource.data.buyerId &&
         request.resource.data.sellerId == resource.data.sellerId &&
         request.resource.data.listingId == resource.data.listingId) ||
        (resource.data.sellerId == request.auth.uid &&
         // Seller can only update status to in_transit or delivered
         (request.resource.data.status == 'in_transit' || request.resource.data.status == 'delivered') &&
         // Never allow seller to mutate payout/payment/admin-controlled fields
         !request.resource.data.diff(resource.data).changedKeys().hasAny([
           'amount','platformFee','sellerAmount',
           'stripeCheckoutSessionId','stripePaymentIntentId','stripeTransferId','stripeRefundId',
           'sellerStripeAccountId','releasedBy','releasedAt','refundedBy','refundedAt','refundReason','refundAmount',
           'adminHold','adminHoldReason','adminActionNotes',
           'paidAt','disputeDeadlineAt','deliveryConfirmedAt','protectionStartAt','protectionEndsAt','payoutHoldReason',
           'protectedTransactionDaysSnapshot','protectedTermsVersion','chargebackStatus'
         ]) &&
         request.resource.data.buyerId == resource.data.buyerId &&
         request.resource.data.sellerId == resource.data.sellerId &&
         request.resource.data.listingId == resource.data.listingId) ||
        isAdmin() // Admins can update orders (e.g., to complete payouts, set adminHold)
      );
      
      // No deletes allowed
      allow delete: if false;
      
      // Documents subcollection
      match /documents/{documentId} {
        // IMPORTANT: subcollection docs do NOT necessarily contain buyerId/sellerId; always reference the parent order.
        function parentOrder() {
          return get(/databases/$(database)/documents/orders/$(orderId));
        }
        function isOrderParticipant() {
          return isAuthenticated() && parentOrder().data != null && (
            parentOrder().data.buyerId == request.auth.uid ||
            parentOrder().data.sellerId == request.auth.uid
          );
        }

        // Allow read: buyer, seller, or admin
        allow read: if isOrderParticipant() || isAdmin();
        
        // Allow create: buyer or seller uploading their own doc
        allow create: if isOrderParticipant() &&
          request.resource.data.status == 'uploaded' &&
          request.resource.data.uploadedBy == request.auth.uid;
        
        // Allow update: only admin (for verification)
        allow update: if isAdmin() && 
          (request.resource.data.status == 'verified' || request.resource.data.status == 'rejected') &&
          request.resource.data.verifiedBy == request.auth.uid;
        
        // No delete allowed
        allow delete: if false;
      }
    }

    // ============================================
    // OFFERS COLLECTION (Best Offer)
    // ============================================
    match /offers/{offerId} {
      // Read-only for buyer/seller/admin.
      // Writes are server-side only (Admin SDK via API routes).
      allow read: if isAuthenticated() && (
        resource.data.buyerId == request.auth.uid ||
        resource.data.sellerId == request.auth.uid ||
        isAdmin()
      );
      allow create, update, delete: if false;
    }

    // ============================================
    // OPS HEALTH (Admin-only read)
    // ============================================
    match /opsHealth/{docId} {
      allow read: if isAdmin();
      allow create, update, delete: if false;
    }
    
    // ============================================
    // MESSAGE THREADS COLLECTION
    // ============================================
    match /messageThreads/{threadId} {
      function isThreadParticipant() {
        return isAuthenticated() && (
          resource.data.buyerId == request.auth.uid ||
          resource.data.sellerId == request.auth.uid ||
          isAdmin()
        );
      }

      // Fields a normal participant is allowed to change on the thread doc.
      // Everything else is admin/server controlled.
      function participantAllowedThreadUpdate() {
        return request.resource.data.diff(resource.data).affectedKeys().hasOnly([
          'buyerUnreadCount',
          'sellerUnreadCount',
          'unreadCount',
          'updatedAt',
          'flagged',
          'flagCount',
          'flaggedBy',
          'flaggedAt',
          'flaggedReason',
          'flaggedDetails'
        ]) &&
        // Disallow changing core identity fields
        request.resource.data.buyerId == resource.data.buyerId &&
        request.resource.data.sellerId == resource.data.sellerId &&
        request.resource.data.listingId == resource.data.listingId;
      }

      // Allow read: if user is buyer or seller in the thread, OR if admin
      allow read: if isAuthenticated() && (
        resource.data.buyerId == request.auth.uid ||
        resource.data.sellerId == request.auth.uid ||
        isAdmin()
      );
      
      // Allow create: if authenticated and user is buyer or seller
      allow create: if isAuthenticated() && (
        request.resource.data.buyerId == request.auth.uid ||
        request.resource.data.sellerId == request.auth.uid
      );
      
      // Allow update: if user is buyer or seller, OR if admin (for flagging)
      allow update: if isAuthenticated() && (
        isAdmin() ||
        (isThreadParticipant() && participantAllowedThreadUpdate())
      );
      
      // Allow delete: only admin
      allow delete: if isAdmin();
      
      // Messages subcollection
      match /messages/{messageId} {
        // Thread participant check (avoid outages when older message docs are missing recipientId, etc.)
        function isThreadParticipant() {
          let t = get(/databases/$(database)/documents/messageThreads/$(threadId)).data;
          return t.buyerId == request.auth.uid || t.sellerId == request.auth.uid || isAdmin();
        }

        // Allow read: if user is a participant in the parent thread (or admin)
        allow read: if isAuthenticated() && isThreadParticipant();
        
        // Allow create: if authenticated, user is sender, AND user is a participant in the parent thread
        allow create: if isAuthenticated() &&
          request.resource.data.senderId == request.auth.uid &&
          isThreadParticipant();
        
        // Allow update: only admin (for flagging)
        allow update: if isAdmin();
        
        // No deletes allowed
        allow delete: if false;
      }
    }
    
    // ============================================
    // STRIPE EVENTS COLLECTION (Idempotency)
    // ============================================
    match /stripeEvents/{eventId} {
      // Only server-side (Admin SDK) can write
      // No client access needed
      allow read, write: if false;
    }
    
    // ============================================
    // CHARGEBACKS COLLECTION
    // ============================================
    match /chargebacks/{disputeId} {
      // Only server-side (Admin SDK) can write
      // Admins can read for dashboard
      allow read: if isAdmin();
      allow write: if false; // Server-side only
    }
    
    // ============================================
    // AUDIT LOGS COLLECTION
    // ============================================
    match /auditLogs/{auditId} {
      // Write-only (server-side only)
      // Admins can read for accountability
      allow read: if isAdmin();
      allow write: if false; // Server-side only (Admin SDK)
      allow delete: if false; // No deletions allowed
    }

    // ============================================
    // ADMIN USER MANAGEMENT (SERVER-WRITTEN)
    // ============================================
    match /userSummaries/{userId} {
      // Read: admin-only (used by admin directory + dossier)
      allow read: if isAdmin();
      // Write: server-side only (Admin SDK)
      allow write: if false;
      allow delete: if false;
    }

    match /adminUserNotes/{userId} {
      allow read: if isAdmin();
      allow write: if false;
      allow delete: if false;

      match /notes/{noteId} {
        allow read: if isAdmin();
        allow write: if false;
        allow delete: if false;
      }
    }

    // ============================================
    // NOTIFICATIONS COLLECTION
    // ============================================
    match /notifications/{notificationId} {
      // Allow read: only the recipient can read their notifications
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;

      // P0: Notifications are server-controlled (Admin SDK) to prevent spoofing.
      allow create: if false;

      // Allow update: only recipient (mark as read)
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;

      // No delete allowed
      allow delete: if false;
    }

    // ============================================
    // CANONICAL NOTIFICATION EVENT STREAM + JOB QUEUES
    // ============================================
    match /events/{eventId} {
      allow read: if isAdmin();
      allow write: if false;
    }
    match /emailJobs/{jobId} {
      allow read: if isAdmin();
      allow write: if false;
    }
    match /pushJobs/{jobId} {
      allow read: if isAdmin();
      allow write: if false;
    }
    match /smsJobs/{jobId} {
      allow read: if isAdmin();
      allow write: if false;
    }
    match /notificationRateLimits/{docId} {
      allow read: if isAdmin();
      allow write: if false;
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
